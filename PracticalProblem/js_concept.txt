javascript concept example
========================== IIFE ========================
IIFE takes anonymious function as input

(function (){
    console.log("Hello")
})()


IIFE with Parameters 
(function(name) { 
    console.log(`Hello, ${name}!`); 
})("John");

========================== Hoisting ====================
function parent (){
    var a = 300;
    return function() {  
        console.log(a); // reference error     
        let a = 200; 
        console.log(a); // 
    } 
}
==========================let vs var ===================

for (var i = 0; i < 3; i++) {
    setTimeout(() => {
        console.log(i);
    }, 1000);
}

o/p 3,3,3 


if asked to solved using var only we can use IIFE which will create new scope in each iteration

for (var i = 0; i < 3; i++) {
    ()(function(i){
        setTimeout(() => {
            console.log(i);
        }, 1000);
    })(i)
}



// can be solved by putting it under IIFE 

for (let i = 0; i < 3; i++) {
    setTimeout(() => {
        console.log(i);
    }, 1000);
}
o/p 0,1,2

=====================Shallow vs Deep Copy =============
const obj1 = {a:10, b: {c:20}};
const obj2 = {...obj1};

obj2.a= 30 // example when root elem updated

console.log("Try programiz.pro", obj2); // {a:30, b: {c:20}}
console.log("Try programiz.pro", obj1); // {a:10, b: {c:20}}


obj2.b.c= 30 // example when nested elem updated

console.log("Try programiz.pro", obj2); // {a:10, b: {c:30}}
console.log("Try programiz.pro", obj1); // {a:10, b: {c:30}}


===================== Currying =========================

function x(a) {
    return function (b) {
        return function (c) {
            return a * b * c;
        };
    };
}


console.log("currying example ", x(1)(2)(3));
====================== callback ========================
function greet(name) {
    return "Hello " + name;
}

function welcome(name, callback) {
    return callback(name);
}

console.log("Greet: ", welcome("Rahul", greet)); // Greet: Hello Rahul

==================== Promise & async await =======================
const p1 = new Promise((res, rej)=> res("success"))
const p2 = new Promise((res, rej)=> rej("failure"))
const p3 = new Promise((res, rej)=> rej("failed"))

Promise.all([p1,p2,p3])
    .then(res=> console.log(res))
    .catch(err=> console.log(err))

Promise.race([p2,p3, p1])
    .then(res=> console.log(res)) // settles as soon as any of the promises in the iterable settle (either fulfill or reject)
    .catch(err=> console.log(err))
    
Promise.any([p1,p2,p3])
    .then(res=> console.log(res)) // settles as soon as any of the promises in the iterable fulfills.
    .catch(err=> console.log(err))

----------------------- async await ------------------------------
async function getPromise() {
    const urls = ["https://api.example1.com", "https://api.example2.com"];
    const responses = await Promise.all(urls.map(url => fetch(url).then(res => res.json())));
    return responses;
}

const res = await getPromise();
console.log("getPromise ", res);

-----------------------async await with setTimeout -------------------
function delay(time){
    return new Promise(res => setTimeout(()=> res("Hello World"), time))
}

async function getDelayresult(){
    return await delay(2000);
}

getDelayresult().then(res=> console.log(res))

============================= custom map and fitler ==================
Array.prototype.customMap = function(callback){
    const arr =[];
    for(let i=0;i<this.length;i++) {
        arr.push(callback(this[i]));
    }
    return arr
}

Array.prototype.customFilter = function(callback){
    const arr =[];
    for(let i=0;i<this.length;i++) {
        !!callback(this[i]) && arr.push(this[i]);
    }
    return arr
}

console.log("customMap ", [1,2,3,4,5].customMap((item)=> item*2));

console.log("customFilter ", [1,2,3,4,5].customFilter((item)=> item%2===0));

===========================Node JS ========================================
making 3rd party API Call

const express = require('express');

const app = express();
const PORT = 3000;

app.get('/data', async (req, res) => {
    try {
        const response = await fetch('https://jsonplaceholder.typicode.com/posts/1');
        const data = await response.json();
        res.json(data);
    } catch (error) {
        res.status(500).json({ error: 'Failed to fetch data' });
    }
});

app.listen(PORT, () => console.log(`Server running on port ${PORT}`));


----------------------------------Event --------------------------
const events = require("events");
const emitter = new events.EventEmitter();

emitter.on("event_name", ()=> {})
emitter.emit("event_name");
-----------------------------------Cluster--------------------------------
const cluster = require("cluster");
const os = require("os");
const express = require("express");

const cpuLength = os.cpu().length;

if(cluseter.isMaster) {
    for(let i=0;i<cpuLength;i++){
        cluster.fork()
    }
    cluster.on("exit", (worker)=> {
        cluster.fork();
    })
} else {
    app = express();
    app.get('/', ()=> "Hello World")
    app.listen(3000)
}
=======================OCP======================
Wrong

type CustomerType=  "Regular" | "Premium"; 

class Customer { 
    getDiscount(customerType: CustomerType){ 
        If(customerType === "Regular") return :10; 
        Else If(customerType === "Premium") return  20 
        Else return 10; 
    } 
} 

It violate OCP as for new customer type existing method need to be updated.

Right

Interface Customer {
    getDiscount();
}

class PremiumCustomer implements Customer{
    getDiscount(){
        return 15
    }
}

class RegularCustomer implements Customer{
    getDiscount(){
        return 10
    }
}

class Discount {
    giveDiscount(customer){
        customer.getDiscount()
    }
}

const regularCustomer = new RegularCustomer();
const discount = new Discount()
discount.giveDiscount(regularCustomer);
================================LSP============================
Wrong

interface bird{
    fly()
}

class eagle implements bird {
    fly(){
        console.log("Fly  high")
    }
}

class penguin implements bird {
    fly(){
        throw new Error("I can't fly")
    }
}

Here it violating LSP as subclass penguin need to define fly method even though it can't beacuse it implement bird class

Right

interface bird{
    eat()
}

interface flyingbird extends bird{
    fly()
}

interface swimmmingbird extends bird{
    swim()
}

class eagle implements flyingbird {
    fly(){
        console.log("Fly  high")
    }

    eat(){}
}

class penguin implements swimmingbird {
    swim(){
        console.log("swim  in water")
    }
    eat(){}
}
====================================DIP==============================
wrong

class EmailService {
    sendEmail(){}
}

class SendNotification {
    constructor(email: EmailService){}

    send(){
        email.sendEmail()
    }
}
Here it violating DIP as send notifation is tightly coupled with EmailService and if some new requirement come 
whole code will change.

right


Interface MessageSender {
    sendMessage()
}

class EmailService implements MessageSender{
    sendMessage(){}
}

class SmsService implements MessageSender{
    sendMessage(){}
}

class SendNotification {
    constructor(sender: MessageSender){}

    send(){
        sender.sendEmail()
    }
}
-------------------------Singleton-------------------
class Singleton {
    static instance; // Static property
    data;

    constructor() {
        this.data = "default data";
    }

    static getInstance() {
        if (!Singleton.instance) {  // ✅ Correct spelling
            Singleton.instance = new Singleton(); // ✅ Fixed typo
        }
        return Singleton.instance;
    }

    setData(data) {
        this.data = data;
    }

    getData() {
        return this.data;
    }
}

// Creating instances
const s1 = Singleton.getInstance();
s1.setData("Cow");

const s2 = Singleton.getInstance();
s2.setData("Dog");

console.log("Are same:", s1 === s2); // ✅ Output: true
console.log("Data from s1:", s1.getData()); // ✅ Output: "Dog"
console.log("Data from s2:", s2.getData()); // ✅ Output: "Dog"

-------------------------------------------------------------------

class Truck {
    constructor(name, model){
        this.name=name;
        this.version=version
    }
    drive(){
        return `I am driving ${this.name} version  ${this.version}`
    }
}

class Car {
    constructor(name, model){
        this.name=name;
        this.version=version
    }
    drive(){
        return `I am driving ${this.name} version  ${this.version}`
    }
}

class VehiceFactory {
    static createVehicle(type){
        switch(type){
            case "Car": 
                return new Car("BMW", "2.0")
            case "Truck": 
                return new Car("Volvo", "2.0")
            default:
                throw new Error("No match")
        }
    }
}
----------------------------------------------------------------


